// Module included in the following assemblies:
//
// * nodes/nodes-nodes-problem-detector.adoc

[id='nodes-nodes-problem-detector-customizing_{context}']
= Customizing Node Problem Detector conditions

You can configure the Node Problem Detector to watch for any log string by editing the Node Problem Detector custom resource (CR).

.Prerequisites

* The Node Problem Detector Operator must be installed.

* If needed, get the name of the Node Problem Detector CR:
+
----
$ oc get NodeProblemDetector
NAME                    AGE
node-problem-detector   6m6s
----

* Set the Node Problem Detector to the unmanaged state. In managed state, the Node Problem Detector Operator reverts changes made to the problem node detector configuration map.

.Procedure

To modify the Node Problem Detector:

. Open the Node Problem Detector CR for editing.
+
----
$ oc edit problem-node-detector <node>
----
+
For example:
+
----
oc edit problem-node-detector problem-node-detector

apiVersion: node-problem-detector.operator.k8s.io/v1alpha1
kind: NodeProblemDetector
metadata:
  creationTimestamp: 2019-03-04T00:18:48Z
  generation: 1
  name: node-problem-detector
  namespace: default
  resourceVersion: "47179"
  selfLink: /apis/node-problem-detector.operator.k8s.io/v1alpha1/namespaces/default/nodeproblemdetectors/node-problem-detector
  uid: 14acef47-3e13-11e9-a640-0a4ad769663a
namespace: openshift-node-problem-detector
----

. Change the parameters and values as needed: 
+
.Sample Node Problem Detector Configuration Map
[source,yaml]
----
spec:
  kernel-monitor.json: |  <1>
    {
        "plugin": "journald", <2>
        "pluginConfig": {
                "source": "kernel"
        },
        "logPath": "/host/log/journal", <3>
        "lookback": "5m",
        "bufferSize": 10,
        "source": "kernel-monitor",
        "conditions": [                 <4>
                {
                        "type": "KernelDeadlock", <5>
                        "reason": "KernelHasNoDeadlock", <6>
                        "message": "kernel has no deadlock"  <7>
                }
        ],
        "rules": [                         <8>
                {
                        "type": "temporary",
                        "reason": "OOMKilling",
                        "pattern": "Kill process \\d+ (.+) score \\d+ or sacrifice child\\nKilled process \\d+ (.+) total-vm:\\d+kB, anon-rss:\\d+kB, file-rss:\\d+kB"
                },
                {
                        "type": "temporary",
                        "reason": "TaskHung",
                        "pattern": "task \\S+:\\w+ blocked for more than \\w+ seconds\\."
                },
                {
                        "type": "temporary",
                        "reason": "UnregisterNetDevice",
                        "pattern": "unregister_netdevice: waiting for \\w+ to become free. Usage count = \\d+"
                },
                {
                        "type": "temporary",
                        "reason": "KernelOops",
                        "pattern": "BUG: unable to handle kernel NULL pointer dereference at .*"
                },
                {
                        "type": "temporary",
                        "reason": "KernelOops",
                        "pattern": "divide error: 0000 \\[#\\d+\\] SMP"
                },
                {
                        "type": "permanent",
                        "condition": "KernelDeadlock",
                        "reason": "AUFSUmountHung",
                        "pattern": "task umount\\.aufs:\\w+ blocked for more than \\w+ seconds\\."
                },
        ]
    }

  kubelet-monitor.json: |-
    {
        "plugin": "custom",
        "pluginConfig": {
            "invoke_interval": "120s",
            "timeout": "60s",
            "concurrency": 1
        },
        "source": "kubelet-custom-plugin-monitor",
        "conditions": [{
            "type": "KubeletProblem",
            "reason": "KubeletIsUp",
            "message": "kubelet is up"
        }],
        "rules": [{
                "type": "temporary",
                "reason": "KubeletIsDown",
                "path": "/etc/npd-plugins/kubelet-health.sh",
                "timeout": "30s"
            },
            {
                "type": "permanent",
                "condition": "KubeletProblem",
                "reason": "KubeletIsDown",
                "path": "/etc/npd-plugins/kubelet-health.sh",
                "timeout": "45s"
            }
        ]
    }

----

<1> Rules and conditions that apply to container images.
<2> Monitoring services, in a comma-separated list.
<3> Path to the monitoring service log.
<4> List of events to be monitored.
<5> Label to indicate the error is an event (`temporary`) or NodeCondition (`permanent`).
<6> Text message to describe the error.
<7> Error message that the Node Problem Detector watches for.
<8> Rules and conditions that apply to the kernel.

////
https://kubernetes.io/docs/tasks/debug-application-cluster/monitor-node-health/#node-problem-detector
The Node Problem Detector supports file-based kernel logging. However, it is easy to extend it to support other log formats.
////

. Optionally, you can add new node conditions or events:
+
[source,yaml]
----
{
       "type": <`temporary` or `permanent`>,
       "reason": <free-form text describing the error>,
       "pattern": <log message to watch for>
},
----
+
For example:
+
[source,yaml]
----
{
       "type": "temporary",
       "reason": "UnregisterNetDevice",
       "pattern": "unregister_netdevice: waiting for \\w+ to become free. Usage count = \\d+"
},
----

. To display Node Problem Detector output to standard output (stdout) and standard error (stderr)
add the following to the configuration map:
+
[source,yaml]
----
spec:
  template:
    spec:
      containers:
      - name: node-problem-detector
        command:
        - node-problem-detector
        - --alsologtostderr=true <1>
        - --log_dir="/tmp" <2>
        - --system-log-monitors=/etc/npd/kernel-monitor.json <3>
----
+
<1> Sends the output to standard output (stdout).
<2> Path to the error log.
<3> Comma-separated path to the plug-in configuration files.


// Module included in the following assemblies:
//
// * architecture/architecture.adoc

[id='operators-overview-{context}']
= Operators in {product-title}

{product-title} v4 uses different classes of Operators to perform cluster 
operations and run services on the cluster for your applications to use.

[id='-platform-operators-overview-{context}']
== Platform Operators in {product-title}

In {product-title} version 4.0, all cluster functions are divided into a series
of platform Operators. Platform operators manage a particular area of
cluster functionality, such as cluster-wide application logging, management of
the Kubernetes control plane, or the machine provisioning system.

Each Operator provides you with a simple API for determining cluster
functionality. The Operator hides the details of managing the lifecycle of that
component. Operators can manage a single component or tens of components, but
the end goal is always to reduce operational burden by automating common actions.
Operators also offer a more granular configuration experience. You configure each
component by modifying the API that the Operator exposes instead of modifying a
global configuration file.

In {product-title} v4, all control plane components are run and managed as
applications on the infrastructure to ensure a uniform and consistent management
experience. The control plane, services run as static pods so they can
manage normal workloads or processes the same way that they manage disaster
recovery. Aside from the core control plane components, other services run as 
normal pods on the cluster, managed by regular Kubernetes constructs. Unlike in the past
where the `kubelet` could be running as containerized or non-containerized, the `kubelet`
always runs as a `systemd` process.


[id='second-level-operators-{context}']
== Second-level Operators in {product-title}

The cluster version Operator, when we talk about payload manifests, is a
second-level Operator, the Operators that actually manage {product-title} as if
it were a native Kubernetes application. Second-level Operators are not a
codified concept, but thenamespace where your code exists, the service accounts
or roles the second-level Operator runs as, the CRD and pull secret that drives
the operation of the Operator, and the Operator deployment.

Second-level Operators write out to a CRD resource called the cluster Operator
that allows the cluster version Operator to understand the progress of the
managed component's deployment

[id='OLM-operators-{context}']
== Operators managed by OLM

In addition to the Operators that comprise {product-title}, the Cluster
Operator Lifecycle Management (OLM) component manages more Operators.
OLM is a framework that manages Kubernetes-native applications as Operators.
Instead of managing Kubernetes manifests, it manages Kubernetes Operators.
OLM manages two classes of Operators, Red Hat Operators and certified Operators.

Some Red Hat Operators drive the cluster functions, like the scheduler and
problem detectors. Others are provider for you to manage yourself and use in
your applications, like etcd. {product-title} also offers certified Operators,
which the community built around the OLM and maintains. These certified Operators
are traditional applications that are Kubernetes-aware because they are wrapped
in an Operator.

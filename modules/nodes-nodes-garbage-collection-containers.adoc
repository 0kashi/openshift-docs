// Module included in the following assemblies:
//
// * nodes/nodes-nodes-garbage-collection.adoc

[id='nodes-nodes-garbage-collection-containers_{context}']
= Understanding how terminated containers are removed though garbage collection

Container garbage collection is enabled by default and happens automatically in
response to eviction thresholds being reached. The node tries to keep any
container for any pod accessible from the API. If the pod has been deleted, the
containers will be as well. Containers are preserved as long the pod is not
deleted and the eviction threshold is not reached. If the node is under disk
pressure, it will remove containers and their logs will no longer be accessible
via `oc logs`.

The policy for container garbage collection is based on three conditions:

* The minimum age that a container is eligible for garbage collection. The
default is *0*. 

* The number of instances to retain per pod container. The default is *1*.

* The maximum number of total dead containers in the node. The default is *-1*, which means unlimited.

[IMPORTANT]
====
Garbage collection only removes the containers that do not have any pods.
====

For container garbage collection, you can modify any of the following variables using 
a Custom Resource.

.Variables for configuring container garbage collection

[options="header",cols="1,3"]
|===

|Setting |Description

|`*minimum-container-ttl-duration*`
|The minimum age that a container is eligible for garbage collection. The
default is *0*. Use *0* for no limit. Values for this setting can be
specified using unit suffixes such as *h* for hour, *m* for minutes, *s* for seconds.

|`*maximum-dead-containers-per-container*`
|The number of instances to retain per pod container. The default is *1*.

|`*maximum-dead-containers*`
|The maximum number of total dead containers in the node. The default is *-1*, which means unlimited.
|===

The `*maximum-dead-containers*` setting takes precedence over the
`*maximum-dead-containers-per-container*` setting when there is a conflict. For
example, if retaining the number of `*maximum-dead-containers-per-container*`
would result in a total number of containers that is greater than
`*maximum-dead-containers*`, the oldest containers will be removed to satisfy
the `*maximum-dead-containers*` limit.

When the node removes the dead containers, all files inside those containers are
removed as well. Only containers created by the node are removed.

Each spin of the garbage collector loop goes through the following steps:

1. Retrieve a list of available containers.
2. Filter out all containers that are running or are not alive longer than
the `*minimum-container-ttl-duration*` parameter.
3. Classify all remaining containers into equivalence classes based on pod and image name membership.
4. Remove all unidentified containers (containers that are managed by kubelet but their name is malformed).
5. For each class that contains more containers than the
`*maximum-dead-containers-per-container*` parameter, sort containers in the class by
creation time.
6. Start removing containers from the oldest first until the
`*maximum-dead-containers-per-container*` parameter is met.
7. If there are still more containers in the list than the
`*maximum-dead-containers*` parameter, the collector starts removing containers
from each class so the number of containers in each one is not greater than the
average number of containers per class, or
`<all_remaining_containers>/<number_of_classes>`.
8. If this is still not enough, sort all containers in the list and start
removing containers from the oldest first until the `*maximum-dead-containers*`
criterion is met.


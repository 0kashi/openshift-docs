// Module included in the following assemblies:
//
// * architecture/architecture.adoc

[id='architecture-overview-{context}']
= Architecture overview

With {product-title} v4, the core story remains unchanged: {product-title} offers
your developers a set of tools to evolve their applications under operational oversight
and using Kubernetes to provide application infrastructure. The key change to {product-title}4 is
that the infrastructure and its management are flexible, automated, and self-managing.

A major difference between {product-title} 3 and {product-title} 4 is that {product-title} 4 uses Operators
as both the fundamental unit of the product and an option for easily deploying
and managing utilities that your apps use.

{product-title} 4 runs on top of a Kubernetes cluster, with data about the
objects stored in etcd, a reliable clustered key-value store. The cluster is
enhanced with standard components that you need to run your cluster, including
network, ingress, logging, and monitoring, that run as Operators to increase the
ease and automation of installation, scaling, and maintenance.

////
The core services include:

* Operators, which run the core {product-title} services.
* REST APIs, which expose each of the core objects:
** Containers and images, which are the building blocks for deploying your
applications.
** Pods and services, which containers use to communicate with each other and
proxy connections.
** Projects and users, which provide the space and means for communities to
organize and manage their content together.
** Builds and image streams allow you to
build working images and react to new images.
** Deployments, which expand support for the software development and deployment
lifecycle.
** Ingress and routes, which announce your service to the world.
* Controllers, which read those REST APIs, apply changes to other objects, and
report status or write back to the object.
////

{product-title} offers a catalog of supporting application infrastructure that
includes:

* Operators, which expose APIs that automate the complete component lifecycle
and include components like databases
* Service bindings, which consume services that run outside the cluster
* Templates, which are simple instant examples

Users make calls to the REST API to change the state of the system. Controllers
use the REST API to read the user's desired state and then try to bring the
other parts of the system into sync. For example, when you request a build, the
REST APIs create a `build` object. The build controller sees that a new build has been created, and
runs a process on the cluster to perform that build. When the build completes,
the controller updates the build object via the REST API and the user sees that
their build is complete.

The controller pattern means that much of the functionality in {product-title}
is extensible. The way that builds are run and launched can be customized
independently of how images are managed, or how deployments happen. The controllers
perform the "business logic" of the system, taking user actions and
transforming them into reality. By customizing those controllers or replacing
them with your own logic, you can implement different behaviors. From a system
administration perspective, this also means that you can use the API to script common
administrative actions on a repeating schedule. Those scripts are also
controllers that watch for changes and take action. {product-title} makes the
ability to customize the cluster in this way a first-class behavior.

To make this possible, controllers use a reliable stream of changes to the
system to sync their view of the system with what users are doing. This event
stream pushes changes from etcd to the REST API and then to the controllers as
soon as changes occur so changes can efficiently ripple through the system.
However, because failures can occur at any time, the controllers
must also be able to get the latest state of the system at start up and confirm
that everything is in the right state. This resynchronization is important
because it means that even if something goes wrong, you can
restart the affected components, and the system confirms its status before it
continues. Because the controllers can always bring the system into sync, the
system eventually converges to your intent.
